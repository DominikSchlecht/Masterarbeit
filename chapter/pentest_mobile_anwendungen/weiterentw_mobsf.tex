\section{Weiterentwicklung MobSF}
\label{Weiterentwicklung MobSF}
Ein Kernelement dieser Arbeit ist die Weiterentwicklung des Mobile Security Frameworks \textit{MobSF}. Die Funktionen des Frameworks sind bereits unter TODO aufgezeigt. Im Folgenden sind die Änderungen dargestellt, welche an dem Framework vorgenommen und veröffentlicht wurden.

\subsection{Allgemeine Verbesserungen}
Neben Verbesserungen, welche einem genauen Bereich (\textit{Windows-Phone}, \textit{iOS}, \textit{Android}) zuzuordnen sind, gibt es auch einige allgemeine Erweiterungen am \textit{Mobile Security Framework}. Diese sind im Folgenden dargestellt.

\subsubsection{Struktur}
Die Struktur von MobSF war bisher relativ flach. Auf der ersten Ebene findet man die Übergeordneten Module wie den \textit{ApiTester}, \textit{StaticAnalyzer}, \textit{DynamicAnalyzer} sowie den \textit{statischen Content}, \textit{Templates} und Kern-Module des \textit{MobSF}. Dies ist in der Abbildung \ref{fig:MobSFStrukOrig} verdeutlicht. Jedoch hatte die Struktur in den Modulen oft keine saubere Trennung der Aufgaben. So waren im \textit{StaticAnalyzer}-Modul sowohl \textit{iOS} wie auch \textit{Android}-Analyse in der \textit{views.py} zusammengefasst. Um hier eine klarere Trennung zu schaffen, wurde die \textit{views.py} aufgegliedert in drei Dateien:
\begin{description}
	\item[shared\_func.py: ] Die \textit{shared\_func.py} enthält alle Funktionen, welche sowohl für \textit{iOS} als auch \textit{Android} gebraucht werden. Beispiele sind die Erstellung von Hashes, das Generieren von PDFs oder das Entpacken von Archiven.
	
	\item[ios.py: ] Die Datei \textit{ios.py} enthält alle \textit{iOS} spezifischen Funktionen zur statischen Analyse.
	
	\item[android.py: ] Die Datei \textit{android.py} enthält alle \textit{Android} spezifischen Funktionen zur statischen Analyse.
	
	\item[windows.py: ] Die Datei \textit{windows.py} enthält alle \textit{Windows-Phone} spezifischen Funktionen zur statischen Analyse. Sie wurde nachträglich hinzugefügt (siehe \ref{Windows-Apps}), weshalb die Funktionen in der altern Struktur nicht auftauchen.
\end{description}
Dies ist im Detail in der Abbildung \ref{fig:MobSFStaticStrucVergl} dargestellt.

\begin{figure}
\dirtree{%
.1 Mobile-Security-Framework-MobSF/.
    .2 .git/.
    .2 APITester/.
    .2 downloads/.
    .2 DynamicAnalyzer/.
    .2 LICENSES/.
    .2 logs/.
    .2 MalwareAnalyzer/.
    .2 MobSF/.
    .2 static/.
    .2 StaticAnalyzer/.
    .2 templates/.
    .2 uploads/.
}
\label{fig:MobSFStrukOrig}
\caption{Strutkur MobSF auf der ersten Ebene}
\end{figure}

\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \dirtree{%
.1 StaticAnalyzer/.
    .2 [...].
    .2 views.py.
    	.3 key.
    	.3 PDF.
    	.3 Java.
    	.3 Smali.
    	.3 Find.
    	.3 ViewSource.
    	.3 ManifestView.
    	.3 StaticAnalyzer.
    	.3 GetHardcodedCertKeystore.
    	.3 ReadManifest.
    	.3 GetManifest.
    	.3 ValidAndroidZip.
    	.3 HashGen.
    	.3 FileSize.
    	.3 GenDownloads.
    	.3 zipdir.
    	.3 Unzip.
    	.3 FormatPermissions.
    	.3 CertInfo.
    	.3 WinFixJava.
    	.3 WinFixPython3.
    	.3 Dex2Jar.
    	.3 Dex2Smali.
    	.3 Jar2Java.
    	.3 Strings.
    	.3 ManifestData.
    	.3 ManifestAnalysis.
    	.3 CodeAnalysis.
    	.3 StaticAnalyzer\_iOS.
    	.3 ViewFile.
    	.3 readBinXML.
    	.3 HandleSqlite.
    	.3 iOS\_ListFiles.
    	.3 BinaryAnalysis.
    	.3 iOS\_Source\_Analysis.
}
  \caption{Alte Struktur}
  \label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \dirtree{%
.1 Mobile-Security-Framework-MobSF/.
    .2 [...].
    .2 views/.
		.3 android.py.
	    	.4 [...].
	    	.4 GetHardcodedCertKeystore.
	    	.4 ReadManifest.
	    	.4 GetManifest.
	    	.4 ValidAndroidZip.
	    	.4 Dex2Jar.
	    	.4 Dex2Smali.
	    	.4 Jar2Java.
	    	.4 [...].
		.3 ios.py.
	    	.4 StaticAnalyzer\_iOS.
	    	.4 ViewFile.
	    	.4 readBinXML.
	    	.4 HandleSqlite.
	    	.4 iOS\_ListFiles.
	    	.4 BinaryAnalysis.
	    	.4 iOS\_Source\_Analysis.
	    .3 windows.py.
	    	.4 [...].
	    	.4 \_\_binskim.
	    	.4 \_\_binscope.
	    	.4 [...].
		.3 shared\_func.py.
	    	.4 key.
	    	.4 FileSize.
	    	.4 HashGen.
	    	.4 Unzip.
	    	.4 PDF.
}
  \caption{Neue Struktur}
  \label{fig:sub2}
\end{subfigure}
\caption{Vergleich der Struktur von \textit{StaticAnalyzer}}
\label{fig:MobSFStaticStrucVergl}
\end{figure}

Im weiteren Verlauf der Weiterentwicklung und mit der Einführung von Code-Standards (siehe \ref{pylintering}) wurde die Struktur weiter verfeinert.

TODO

\subsubsection{Namedtuple vs. DICT}
TODO

\subsubsection{Code-Standards}
\label{pylintering}
Bei der Neu- oder Reimplementierung wurde auf die Verwendung von offiziellen Style-Guides geachtet. Insbesondere wurde der\textit{ PEP 8} Standard \footnote{\url{https://www.python.org/dev/peps/pep-0008/}} für Python verwendet, welcher die Lesbarkeit und Wartbarkeit von Python-Code verbessern soll. Um die Einhaltung des Standards zu gewährleisten, wurde das Tool \textit{Pylint} verwendet. Dieses prüft einen gegebenen Quellcode gegen den Code-Standard \textit{PEP 8} und kreiert entsprechende Warnungen für Abweichungen. Ursprünglich musste \textit{Pyling} auf der Konsole extra ausgeführt werden, jedoch können moderne Entwicklungsumgebungen wie \textit{Atom} \textit{Pylint} direkt einbinden und nutzen. Dies hat den Vorteil, dass bereits während dem Programmieren Verstöße gegen Standard oder Fehler wie zum Beispiel falsche Variablennamen entdeckt werden.\\

Für \textit{MobSF} wurde nicht von Anfang an mit Code-Standards entwickelt, weshalb zum Beispiel die Datei \textit{android.py} über 2000 Code-Zeilen mit über 1600 \textit{Pylint}-Fehler aufwies. Durch aufwendige Refaktorierungs- und Umstrukturierungsarbeiten konnte die Anzahl der Abweichungen massiv reduziert werden.\\

Daraus ergibt sich erhöhte Wartbarkeit sowie eine einfachere Entwicklung aufgrund weniger Merge-Konflikte. Dies ist möglich, da die jeweiligen Methoden je nach Funktionalität in entsprechende Module ausgelagert wurden und somit nur die eine, für die Funktion benötigte Datei, verändert und wieder in das Haupt-Projekt eingegliedert werden muss. Zuvor musste bei paralleler Entwicklung am Projekt auch nur eine kleine Änderung in die übergreifende Datei mit Änderungen einer parallel arbeitenden Partei zusammengeführt werden, was oftmals viel Arbeit bedeutet.

TODO pep8 vs flake8 vs xxx..

\subsubsection{strings}
Zuerst wurde das MobSF um die Fähigkeit erweitert, eine iOS-Applikation mit dem \textit{strings}-Programm zu untersuchen. \textit{strings} durchsucht, insofern keine zusätzlichen Parameter übergeben werden, eine binäre Datei mach 4 aufeinander folgende ASCII-Elemente.\\

Dies hilft oft bei einer ersten Einschätzung der Anwendung, da oft eine grundlegende Funktionsweise und der Zweck der Software abgeleitet werden kann. Ebenso können eventuell unbeabsichtigt im Programm vergesse Strings in einer App aufgedeckt werden. Auch sind gelegentlich Funktionsnamen oder Kernel-Calls als String in einem Binary enthalten, was unter TODO zum Entdecken von verwundbaren Funktionen genutzt wird.\\

Sowohl \textit{Mac-OSX} wie auch \textit{Linux} haben ein integriertes \textit{string}-Kommando, welches jedoch \textit{Windows} fehlt. Um die Multi-Platform-Fähigkeit weiterhin zu gewährleisten, wurde die Funktionsweise in Python-Code abgebildet. Als Vorlage wurde ein bestehender Code von \textit{Stackoverflow} \footnote{\url{http://stackoverflow.com/a/17197027}} genutzt. Dieser lieferte jedoch eine wesentlich höhere Anzahl von Ergebnissen, da bestimmte Whitespace-Character ebenfalls beachtet wurden:
\begin{lstlisting}
> wc -l strings_test_*
	  85149 strings_test_orig
  	541393 strings_test_pyth
    626542 total
\end{lstlisting}

Da viele der zusätzlich aufgedeckten Strings jedoch nicht bei der Analyse geholfen, sonder eher das Auffinden relevanter Strings erschwert haben, wurde der Originalcode wie folgt angepasst:
\begin{lstlisting}
<<<<<<< Vor Anpassung
import string
=======
>>>>>>> Nach Anpassung

def strings(filename, min=4):
    """Print out all connected series of readable chars longer than min."""
    with open(filename, "rb") as f:
        result = ""
        for c in f.read():
<<<<<<< Vor Anpassung
            if c in string.printable:
=======
            if c in (
                    '0123456789'
                    'abcdefghijklmnopqrstuvwxyz'
                    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                    '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ '
            ):
>>>>>>> Nach Anpassung
                result += c
                continue
            if len(result) >= min and result[0].isalnum():
                yield "'" + result + "'"
            result = ""
\end{lstlisting}
Durch die Reduzierung der ausschlaggebenden Zeichen konnten die Ergebnisse optimiert werden, sodass eine effiziente Suche über Strings wieder möglich ist.

\subsubsection{PDF-Generation}
Um eine effiziente Weitergabe der Ergebnisse zu ermöglichen, besitzt das \textit{Mobile Security Framework} eine PDF-Export-Funktion. Die Implementierung ist dabei relativ einfach. Es wird eine neue HTML-Sicht geschaffen, welche anschließend über das das Python-Modul \textit{xhtml2pdf.pisa} als PDF geöffnet wird.

Eine solche Sicht wurde jeweils für alle Erweiterungen implementiert, welche in dieser Arbeit vorgenommen wurden.

\subsubsection{RPC-Service}
Um eine Kommunikation zwischen verschiedenen Virtuellen Maschinen zu ermöglichen, wurde ein minimaler \textit{RPC-Server} in Python 3.5 entwickelt. Hierzu wurden verschiedene Ansätze untersucht. Getestet wurden hierzu die Python-Module \textit{Flask}, \textit{Requests}, \textit{xmlrpc} sowie \textit{RSA} zum Hinzufügen einer Authentisierung.

\paragraph{Flask}\label{ref:flask}
Flask ist ein schneller, minimaler Webserver. Mit nur sehr wenig Code es möglich, eine Schnittstelle bereit zu stellen. Ein Code mit zwei akzeptierenden Funktionen, basierend auf der Schnellstart-Anleitung\footnote{\url{http://flask.pocoo.org/docs/0.10/quickstart/}}, ist in Abbildung \ref{ref:rpc_client.py} dargestellt.
\begin{figure}
\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
	print("Execute command!")
    return 'Hello World!'
    
@app.route('/second_command/')
def not_hello_world():
	print("Execute second command!")
    return 'Goodbye World!'

if __name__ == '__main__':
    app.run()
\end{lstlisting}
\label{ref:rpc_client.py}
\caption{rpc\_client.py}
\end{figure}

Es wird eine minimale Anwendung erstellt, welche auf dem Pfad "\url{/}" lokal das \textit{print}-Statement ausführt und den Text 'Hello World!' zurück gibt. 
Wir die Anwendung unter dem Pfad "\url{/second_command/}" angesprochen, wird ein anderes \textit{print}-Statement ausgeführt und ein anderer Wert zurück gegeben. Auf diese Weise können schnell API-Funktionen auf verschiedene Pfade gelegt und angesprochen werden.

\paragraph{Requests}
\textit{Requests} ist ein Python-Modul, welche einfache Anfragen (sogenannte \textit{Requests}) über HTTP(S) ermöglicht. So ist es über ein kurzes Code-Snippet, dargestellt in Abbildung \ref{ref:rpc_server.py}, möglich die unter \ref{ref:rpc_client.py} aufgezeigt Schnittstelle anzusprechen.

\begin{figure}
\begin{lstlisting}
import requests

r = requests.get('http://localhost:5000')
print(r.text)

r = requests.get('http://localhost:5000/second_command/')
print(r.text)
\end{lstlisting}
\label{ref:rpc_server.py}
\caption{rpc\_server.py}
\end{figure}

Wird zuerst der Code \ref{ref:rpc_client.py} und anschließend der Code \ref{ref:rpc_server.py} ausgeführt, wird auf Server-Seite folgende Ausgabe erzeugt:
\begin{lstlisting}
 $ python3 rpc_server.py
Hello World!
Goodbye World!
\end{lstlisting}
Auf der Client-Seite erfolgt folgende Ausgabe:
\begin{lstlisting}
 $ python3 rpc_client.py
 * Running on http://127.0.0.1:5000/
Execute command!
127.0.0.1 - - [18/May/2016 19:10:56] "GET / HTTP/1.1" 200 -
Execute second command!
127.0.0.1 - - [18/May/2016 19:10:56] "GET /second_command/ HTTP/1.1" 200 -
\end{lstlisting}

Aufgrund dieser Basis wurde die erste Version des RPC-Servers implementiert.

\paragraph{xmlrpc mit rsa}
Bei der Eingliederung der Verbindung zwischen der virtuellem Maschine und dem Host wurde jedoch die Anforderung nach einer Möglichkeit zur Authentifizierung gefordert.\\

Zur Implementierung dieser Anforderung wurde das Python-Modul \textit{rsa} verwendet, welches sowohl für Python 2 wie auch Python 3 existiert. Die Funktionsweise ist dabei wie folgt.

TODO Zustandsdiagramm

Durch das Signieren einer bei jedem Funktionsaufruf neu generierten Challenge ist sichergestellt, dass nur der echte Host die Funktion aufruft und ist ebenfalls gegen Replay-Attacken geschützt TODO zu Replay.\\

Jedoch gab es bei der Implementierung über Flask sowie mit den verschiedenen Python-Versionen zwischen Server und Client verschiedene Probleme. So gibt es in Python 2 einen dedizierten Variablen-Typ namens \textit{string}, wohingegen Python 3 Strings in codierten Byte-Objekten speichert. Eine Konvertierung ist an sich möglich und wurde später auch umgesetzt. Jedoch legt \textit{Flask} eine weitere Ebene des Encodings über den übertragenen Inhalt, weshalb es leider nicht möglich war, die kryptographische Signatur fehlerfrei zu übertragen. Aus diesem Grund wurde nach weiteren und eventuell besser geeigneten Alternativen gesucht.\\

Nach einer kurzen Suche bot sich das Modul \textit{xmlrpclib} (Python 2)/\textit{xmlrpc} (Python 3) an. Es ermöglicht die Kommunikation über das standardisierte TODO XML-RPC-Protokoll und ist somit unabhängig von der Python-Version. Zudem können Daten transparent zwischen Server und Client übergeben werden.

\newpage
Es folgt ein kurzes Beispiel, in welcher ein Client eine \textit{hello\_world}-Funktion am Server aufruft.\\

Server-Code:
\begin{lstlisting}
from xmlrpc.server import SimpleXMLRPCServer

def hello_world(name):
	"""Return an Hello-World for a name"""
    return "Hello World {}!".format(name)

if __name__ == '__main__':
	# Open the Server on port 8000
    server = SimpleXMLRPCServer(("0.0.0.0", 8000))
    server.register_function(hello_world, "hello_world")
\end{lstlisting}
$ $\\
Client-Code (\textit{TARGET\_IP} sollte mit der richtigen IP-Adresse ersetzt werden):
\begin{lstlisting}
import xmlrpclib

proxy  = xmlrpclib.ServerProxy(
                "http://{}:{}".format(
                    TARGET_IP, 8000
                )
            )
print proxy.hello_world("John Doe")
\end{lstlisting}
$ $\\
Output des Clients:
\begin{lstlisting}
Hello World John Doe!
\end{lstlisting}

Durch den minimalen eingriff von \textit{xmlrpc} in die Kommunikation, konnte die kryptographische Signatur als \textit{base64} codiertes Datum übergeben werden. Im Folgenden sind kurz die Kern-Funktionen des RSA-Checks aufgezeigt.\\

Client-Code:
\begin{lstlisting}
def _get_token():
    """Get the authentication token for windows vm xmlrpc client."""
    challenge = proxy.get_challenge()
    priv_key = rsa.PrivateKey.load_pkcs1(
        open(settings.WINDOWS_VM_SECRET).read()
    )
    signature = rsa.sign(challenge, priv_key, 'SHA-512')
    sig_b64 = base64.b64encode(signature)
    return sig_b64
    
print proxy.test_challenge(_get_token())
\end{lstlisting}
\newpage
Server-Code:
\begin{lstlisting}
def _check_challenge(signature):
    signature = base64.b64decode(signature)
    try:
        rsa.verify(challenge.encode('utf-8'), signature, pub_key)
        print("[*] Challenge successfully verified.")
        _revoke_challenge()
    except rsa.pkcs1.VerificationError:
        print("[!] Received wrong signature for challenge.")
        raise Exception("Access Denied.")
    except (TypeError, AttributeError):
        print("[!] Challenge already unset.")
        raise Exception("Access Denied.")

def get_challenge():
    """Return an ascii challenge to validate authentication in _check_challenge."""
    global challenge
    # Not using os.urandom for Python 2/3 transfer errors
    challenge = ''.join(
        random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(256)
    )
    return "{}".format(challenge)
    
def test_challenge(signature):
    """Test function to check if rsa is working."""
    _check_challenge(signature)
    print("Check complete")
    return "OK!"
\end{lstlisting}
Durch diese Art der Implementierung ist eine sichere, zuverlässige, effiziente und leicht erweiterbare Kommunikation zwischen Host und virtueller Maschine möglich.


\subsection{Windows-Apps}
\label{Windows-Apps}
Auch wenn die Zukunft der Handy-Sparte von Windows derzeit oftmals in Diskussion steht, geht der Trend zur Entwicklung auf gerade sein Windows 8 und der damit eingeführten TODO Window Unified Platform hin zur Entwicklung von Apps. Der Vorteil, dass diese Apps sowohl auf Windows auf einem PC wie auch auf Handy lauffähig sind, ist schwer bestreiten, macht jedoch eine Umfassende Prüfung der Sicherheit umso wichtiger.\\

Bisher hat das \textit{Mobile Security Framework} noch keine Möglichkeit zur Prüfung von Windows-Apps bereitgestellt. Im Folgenden sind die im Rahmen dieser Arbeit implementierten Features beschrieben.

\subsubsection{Windows Phone Formats}
Um eine App analysieren zu können, muss zu aller erst das File-Format betrachtet und verarbeitet werden. Leider sind im Windows-Umfeld diverse Formate gängig, von welchen im Folgenden einige in Hinblick auf Aufbau und Schutz analysiert werden.

\paragraph{xap}
\textit{XAP} ist ein Format für Windows-Phone-Apps ab \textit{Windows Phone 7} und enthält oft Silverlight-Applikationen.

Ursprünglich war ein \textit{XAP}-File einfach ein ein \textit{ZIP}-Archiv, mit allen Dateien der App. Aus einem solchen \textit{XAP}-File konnte der Inhalt über folgende Schritte einfach gewonnen werden:
\begin{enumerate}
	\item \textit{XAP}-File herunterladen
	\item evtl. Dateiendung von "`.xap"' auf "`.zip"' ändern
	\item mit einem gängigen Archiv-Programm (z.B. 7-Zip) entpacken
\end{enumerate}
Anschließend liegen allen Dateien der App im Extraktions-Ordner.\\

Leider sind \textit{XAP}-Files häufig durch sogenanntes \textit{DRM} (\textit{Digital Rights Management}) geschützt. So lässt sich bei vielen aktuellen XAP-Files folgender Header feststellen:
\begin{lstlisting}
<WRMHEADER xmlns="http://schemas.microsoft.com/DRM/2007/03/PlayReadyHeader" version="4.0.0.0">
	<DATA>
		<PROTECTINFO>
			<KEYLEN>16</KEYLEN>
			<ALGID>AESCTR</ALGID>
		</PROTECTINFO>
		<KID>5zhQkM1z5kq6HCCYD9nceQ==</KID>
		<LA_URL>http://microsoft.com/</LA_URL>
			<CUSTOMATTRIBUTES xmlns="">
				<S>rtXfkbbz4yuPNGrzjQc9yA==</S>
				<KGV>0</KGV>
			</CUSTOMATTRIBUTES>
		<CHECKSUM>TpkeZrwUjIY=</CHECKSUM>
	</DATA>
</WRMHEADER>
\end{lstlisting}

\url{http://forum.xda-developers.com/showpost.php?p=34246750&postcount=3}


The encrypted XAPs use AESCTR, PlayReady. First 32 bytes are a header, last two dwords are a length, the first half (BigEndian) is the 'payload' (actual app(+more?)) and the second half is always -8 bytes. Then comes the 'mal'-formed XML containign PlayReady definitions etc, including base64 encoded key ids etc. I'd like to see someone on custom rom P7 wireshark their network while using a MITM attack (SSL obviously) using an SSL cert accepted as root ca in the phone to see if we can dump any plaintext DRM keys per app, maybe a solid method can be made. For now, not sure. I've been working on it. Key lengths are 16 bytes. I can brute 12 bytes in one month but 16 would take a lot longer. You could also install a custom rom with wdmc on the phone and copy the entire folders off, restructured a little though, unpacked. Hope this helps someone else. All based on PlayReady DRM bs. Smooth Streaming in IIS can support PR too for instance (WRMHEADER aka PlayReady headers):
\url{http://forum.xda-developers.com/showthread.php?t=2046702}

VM + extraction-tool?

Mime-Type: application/x-silverlight-app

\paragraph{appx}
\textit{APPX} ersetzt ab Windows 8.1 das \textit{XAP}-Format.

Extraktion kann über das in Python integrierte Modul \textit{zipfile} erfolgen.
\begin{lstlisting}
import zipfile
files=[]
with zipfile.ZipFile(APP_PATH, "r") as z:
        z.extractall(EXT_PATH)
        files=z.namelist()
return files
\end{lstlisting}
Mime-Type:
\begin{lstlisting}
APPX_MIME = [
    'application/octet-stream',
    'application/vns.ms-appx',
    'application/x-zip-compressed'
]
\end{lstlisting}

\paragraph{appxbundle}

\begin{lstlisting}
['AugmentendApplicationAppx.appx', 'DumbSmash.WindowsPhone_1.1.0.15_language-it.appx', 'DumbSmash.WindowsPhone_1.1.0.15_scale-100.appx', 'DumbSmash.WindowsPhone_1.1.0.15_scale-120.appx', 'DumbSmash.WindowsPhone_1.1.0.15_scale-140.appx', 'AppxMetadata/AppxBundleManifest.xml', 'AppxBlockMap.xml', '[Content_Types].xml', 'AppxSignature.p7x']
\end{lstlisting}

MIME-Type
file --mime-type -b filename

\subsubsection{Virtuelle Maschine zur Analyse von Windows-Apps}
Die virtuelle Maschine zur Analyse von Windows Applikationen setzt sich aus TODO Komponenten zusammen. Für die Software-Komponenten wird ein Installer im Rahmen dieser Arbeit erstellt und zur Verfügung gestellt.
\\\\
Als erstes muss ein Betriebssystem für die Analyse-VM gewählt werden. Normalerweise wäre Windows 7 aufgrund der geringeren Ressourcenauslastung die erste Wahl für Windows-Analyse-Maschinen. Da jedoch der Windows-Phone-Simulator erst ab Windows 8.1 64-Bit unterstützt wird, sollte in Hinsicht auf die dynamische Analyse davon abgesehen und Windows 8.1 64-Bit oder höher verwendet werden. Hier wurde Windows 10 64-Bit verwendet.

Eine weitere Voraussetzung ist Python 3. Getestet wurde in dieser Arbeit mit Python 3.5.2 32-Bit.

Für die restliche Installation wurde ein Installer angefertigt, der die restlichen notwendigen Programme herunterlädt und die Installationen anstößt. Das File ist im Anhang unter TODO zu finden. Genutzt wurden die Bibliotheken \textit{urllib}, \textit{configparser} und \textit{zipfile} sowie \textit{os} zur Ausführung.

Heruntergeladen und Installiert werden folgende Komponenten:
\begin{itemize}
	\item binskim
\end{itemize}
TODO

Die Ordnerstruktur ist dabei wie folgt aufgebaut:
  \dirtree{%
.1 C:/.
    .2 [...].
    .2 MobSF/.
    	.3 Config/.
    		.4 config.txt.
    	.3 Download/.
    	.3 Tools/.    	
}
Die config.txt enthält Inhalte, welche zentral Abgelegt und für verschiedene Skripte eine wichtige Rolle spielen. Ein Beispiel wäre der Pfad zum Verzeichnis, in welchem die Tools gespeichert werden.
Der Downloads-Ordner hält die durch das Setup-Skript heruntergeladenen Binaries.

wdk

\subsubsection{setup.py}
genauer ablauf
statisch unter c Mobsf vs benutzerpfad
switch je nach installationsort
python2/3 kompatibel
\url{https://www.youtube.com/watch?v=17ilENuMj58}


\subsubsection{Statische Analyse}
Um die drei marktführenden mobilen Betriebssysteme mit MobSF abzudecken, wurden Funktionen für Windows-Phone-Apps hinzugefügt.

Zur statischen Analyse wurde das Tool \textit{binskim} von Microsoft getestet \footnote{\url{https://github.com/Microsoft/binskim/releases}}. Das Tool analysiert Compiler-Flags und verschiedenste andere statisch feststellbare Eigenschaften, bewertet diese und gibt die Ergebnisse im SARIF-Format\footnote{\url{https://github.com/sarif-standard/sarif-spec/}} zurück. Leider ist das Tool nur unter Windows ausführbar. Da \textit{MobSF} jedoch auch auf Linux und Mac OS X lauffähig sein soll, wird im folgenden eine virtuelle Windows-Maschine zur statischen und dynamischen Analyse verwendet.
\\\\
\_CRT\_SECURE\_NO\_WARNINGS

\paragraph{Auflistung von Files}

\paragraph{Böse Funktionen}
aus Strings

\subsubsection{Eingebundene Tools}

https://blog.netspi.com/verifying-aslr-dep-and-safeseh-with-powershell/

\paragraph{Binskim}
nuget download

Fehler-Beschreibungen

\paragraph{Binscope}
x64 vs x68
https://github.com/DominikSchlecht/Mobile-Security-Framework-MobSF/issues/10

Fehler-Beschreibungen

\paragraph{Decompiler?}
http://www.telerik.com/products/decompiler.aspx


\subsubsection{Dynamische Analyse von Windows-Apps}
Für das Remote-System sollte beachtet werden, dass für den Phone-Simulator von Microsoft Windows 8.1 Pro 64-Bit oder höher benötigt wird.

Verwendet wird ein \textit{Windows 10 64-Bit} mit \textit{Python 3.5} und \textit{Visual Studio 2015} Community Edition verwendet. Bis auf das Betriebssystem sind keine kostenpflichtigen Programme beteiligt.

windows driver kit für windbg

\subsection{iOS-Apps}
Erster Versuch
Gestarted aus xcode, app:
\begin{lstlisting}
NSURL *url = [NSURL URLWithString:@"https://api.ipify.org"];
SData *data = [NSData dataWithContentsOfURL:url];
NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
\end{lstlisting}
Wireshark output:
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{bilder/pentest_mobile_anwendungen/weiterentw_mobsf/wireshark_simulator.png}
	\caption{Verbindung zu \url{https://api.ipify.org} aus dem iOS-Simulator}
	\label{fig:VergleichLLDBImages}
\end{figure}

Öffnen aus console

mitmproxy vs. http://useyourloaf.com/blog/remote-packet-capture-for-ios-devices/
http://www.binarytides.com/python-packet-sniffer-code-linux/

mitmproxy installieren, Proxy umstellen, https://github.com/ADVTOOLS/ADVTrustStore ausführen und adden, im Iphone aktivieren, neu starten
https://github.com/mitmproxy/mitmproxy/blob/0.18.x/examples/flowbasic

LLDB + Code Simulator (siehe weiter oben)

ausführen von aktionen https://developer.apple.com/reference/xctest
xcrun simctl install booted /Users/dominik/Library/Developer/Xcode/DerivedData/Test2-dzkepdcqdrczebclbvysnxcbwrmp/Build/Products/Debug-iphonesimulator/Test2.app
xcrun simctl launch 4A4B2FF5-C435-4ECB-AC49-A4684F133910 Test2

simulator starten einfach über öffnen von App (IPA => Simulator?)

http://www.libimobiledevice.org/
https://github.com/facebook/FBSimulatorControl
http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation

http://eightbit.io/post/64319534191/how-to-set-up-an-ios-pen-testing-environment

http://www.testplant.com/dlds/eggplant-mobile-eggon/ ?
http://www.sikuli.org/

remote anzeige
git://git.saurik.com/cydia.git
http://kanaka.github.io/noVNC/ als front interface
http://sharedinstance.net/2013/10/running-tweaks-in-simulator/ vnc server auf Iphone installieren, z.B. https://github.com/niknah/veency

TODO: Öffnen aus Console schreiben
TODO: Netzwerkverkehr mitschneiden schreiben
TODO: Installation VNC-Server auf Simulator testen
TODO: VNC in Web-Oberfläche testen