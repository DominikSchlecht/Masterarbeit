\chapter{Penetrationstests mobiler Anwendungen}
\input{chapter/pentest_mobile_anwendungen/bestehende_anwendungen}

\input{chapter/pentest_mobile_anwendungen/vergleich_aktuelle_situation}	


	\section{Anforderungen und Abgleich mit MobSF}
	\begin{itemize}
		\item Automatisierung
		\item Blackbox/Whitebox
		\item Reporting
		\item False-Positive-Rate
	\end{itemize}

	\section{Laboraufbau}
	\section{Entwicklung der Umgebung}
		\subsection{Aufbau}
		\subsection{Schnittstellen}
		\subsection{RPC-Service}
Um eine Kommunikation zwischen den verschiedenen Virtuellen Maschienen zu ermöglichen, wurde ein minimaler RPC-Server in Python 3.5 entwickelt. Verwendet wurden hierzu die Bibliotheken \textit{Flask} und \textit{Requests}.

\subsubsection{Flask}\label{ref:flask}
Flask ist ein schneller, minimaler Webserver. Mit nur sehr wenig Code es möglich, eine Schnittstelle bereit zu stellen. Ein Code mit zwei akzeptierenden Funktionen, basierend auf der Schnellstart-Anleitung\footnote{\url{http://flask.pocoo.org/docs/0.10/quickstart/}}, ist in Abbildung \ref{ref:rpc_client.py} dargestellt.
\begin{figure}
\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
	print("Execute command!")
    return 'Hello World!'
    
@app.route('/second_command/')
def not_hello_world():
	print("Execute second command!")
    return 'Goodbye World!'

if __name__ == '__main__':
    app.run()
\end{lstlisting}
\label{ref:rpc_client.py}
\caption{rpc\_client.py}
\end{figure}

Es wird eine minimale Anwendung erstellt, welche auf dem Pfad "\url{/}" lokal das print-Statement ausführt und den Text 'Hello World!' zurück gibt. 
Wir die Anwendung unter dem Pfad "\url{/second_command/}" angesprochen, wird ein anderes print-Statement ausgeführt und ein anderer Wert zurück gegeben. Auf diese Weise können schnell API-Funktionen auf verschiedene Pfade gelegt und angesprochen werden.

\subsubsection{Requests}
Requests ist eine Python-Bibliothek, welche einfache Anfragen (sogenannte Requests, daher der Name) an Web-Server ermöglicht. So ist es über ein kurzes Code-Snippet, dargestellt in Abbildung \ref{ref:rpc_server.py}, möglich die unter \ref{ref:rpc_client.py} aufgezeigt Schnittstelle anzusprechen.

\begin{figure}
\begin{lstlisting}
import requests

r = requests.get('http://localhost:5000')
print(r.text)

r = requests.get('http://localhost:5000/second_command/')
print(r.text)
\end{lstlisting}
\label{ref:rpc_server.py}
\caption{rpc\_server.py}
\end{figure}

Wird zuerst der Code \ref{ref:rpc_client.py} und anschließend der Code \ref{ref:rpc_server.py} ausgeführt, wird auf Server-Seite folgende Ausgabe erzeugt:
\begin{lstlisting}
 $ python3 rpc_server.py
Hello World!
Goodbye World!
\end{lstlisting}
Auf der Client-Seite erfolgt folgende Ausgabe:
\begin{lstlisting}
 $ python3 rpc_client.py
 * Running on http://127.0.0.1:5000/
Execute command!
127.0.0.1 - - [18/May/2016 19:10:56] "GET / HTTP/1.1" 200 -
Execute second command!
127.0.0.1 - - [18/May/2016 19:10:56] "GET /second_command/ HTTP/1.1" 200 -
\end{lstlisting}

Aufgrund dieser Basis wurde das RPC-Tool implementiert.


		\subsection{Technisches Detail 1}
		\subsection{Technisches Detail 2}
	\section{Abgleich mit Anforderungen}